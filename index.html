<!DOCTYPE html>
<html class="no-js" lang="en">
  <head>
    <script>
      document.documentElement.classList.add("js");
      document.documentElement.classList.remove("no-js");
    </script>
    <title>Component State Switching</title>

    <meta charset="utf-8" />
    <meta content="Jonic Linley" name="author" />
    <meta
      content="width=device-width, initial-scale=1, viewport-fit=cover"
      name="viewport"
    />
    <link crossorigin href="https://fonts.gstatic.com" rel="preconnect" />
    <link
      as="style"
      href="https://fonts.googleapis.com/css?family=Rubik:300,400,500,700&display=swap"
      rel="preload"
    />
    <link
      href="https://fonts.googleapis.com/css?family=Rubik:300,400,500,700&display=swap"
      media="print"
      onload="this.media='all'"
      rel="stylesheet"
    />
    <noscript>
      <link
        href="https://fonts.googleapis.com/css?family=Rubik:300,400,500,700&display=swap"
        rel="stylesheet"
      />
    </noscript>

    <link href="styles.css" rel="stylesheet" />
    <script defer src="sauce.js"></script>
  </head>

  <body>
    <h1>Component State Switching</h1>

    <div class="card" data-sauce-component data-sauce-state="blue">
      <state media="(min-width: 500px)" value="red" />
      <state media="(min-width: 700px)" value="blue" />
      <state media="(min-width: 900px)" value="green" />
      <state media="(min-width: 1100px)" value="green rounded" />

      Hello, World
    </div>

    <h2>What is this?</h2>

    <p>
      For some initial context, read the discussion on
      <a
        href="https://github.com/RaspberryPiFoundation/sauce-design-system/issues/36"
        >this Github issue</a
      >.
    </p>

    <p>The component above has the following markup:</p>

    <pre><code>&lt;div class="card" data-sauce-component&gt;
  &lt;state media="(min-width: 500px)" value="red" /&gt;
  &lt;state media="(min-width: 700px)" value="blue" /&gt;
  &lt;state media="(min-width: 900px)" value="green" /&gt;
  &lt;state media="(min-width: 1100px)" value="green rounded" /&gt;

  Hello, World
&lt;/div&gt;</code></pre>

    <p>In this example, the box should...</p>

    <ol>
      <li>have a grey border when min-width < 500px</li>
      <li>have a red border when min-width >= 500px</li>
      <li>have a blue border when min-width >= 700px</li>
      <li>have a green border when min-width >= 900px</li>
      <li>have a green, rounded border when min-width >= 1100px</li>
    </ol>

    <h2>How does it work?</h2>

    <p>
      Taking inspiration from the <code>&lt;source&gt;</code> elements in the
      HTML specification (as used in the <code>audio</code>,
      <code>picture</code>, and <code>video</code> elements), I’ve created a
      “custom” element for <code>&lt;state&gt;</code>. It’s not a
      <em>true</em> custom element, because the current spec of the
      <code>window.customElements</code> API would make the HTML required for
      our purposes too verbose.
    </p>

    <p>
      I’ve also written the JavaScript necessary to observe the
      <code>&lt;state&gt;</code> elements, attach its
      <code>media</code> attributes to the window, and apply their
      <code>value</code> when the <code>media</code> is triggered on the
      <code>window</code>.
    </p>

    <p>
      However, due to the nature of the <code>window.matchMedia</code> API, it’s
      not possible to easily fall back to the other states if one no longer
      applies.
    </p>

    <p>
      With that in mind I’ve written a <code>SauceStateMachine</code> class,
      that allows a component to apply this fallback when a
      <code>&lt;state&gt;</code> no longer applies.
    </p>

    <p>
      In its current state, the script comes in at around 1.3kB after
      minification. Gzip/Brotli compression would allow us to inline this at the
      bottom of our templates with negligable impact on page speed performance.
    </p>

    <p>
      <strong>Please remember this is just a prototype</strong>. Nothing’s been
      decided, and if this is the direction we’re taking, then the code isn’t
      finalised either. I can already think of one optimisation this script
      requires. Furthermore, we couldn’t just go ahead and use this script on
      the JAMstack. We’d need a
      <a href="https://reactjs.org/docs/higher-order-components.html"
        >Higher Order Component</a
      >
      to make this work with the least fuss.
    </p>

    <p>
      Similarly, for Rails we would require a
      <a href="https://github.com/github/view_component">ViewComponent</a> which
      would perform the same job as the React HOC. Using config we can specify
      the behavior of the elements in the page layout, rather than the
      individual component styles.
    </p>

    <p>
      In the absence of React or Rails, a plain-old JS module can be supplied to
      browsers that understand modules. And browsers that don’t support JS
      modules will be considered the “baseline” experience, which is an
      acceptable fallback.
    </p>

    <p>
      And on top of all <em>that</em>, we should also reconsider our use of the
      word “state”, which is already a concept in React. Possible alternatives
      so far:
    </p>

    <ul>
      <li><code>proviso</code></li>
      <li><code>shape</code></li>
      <li><code>mood</code></li>
      <li><code>footing</code></li>
      <li><code>spirit</code></li>
      <li><code>behavior</code></li>
    </ul>

    <h2>Anything to add?</h2>

    <p>
      Please comment on
      <a
        href="https://github.com/RaspberryPiFoundation/sauce-design-system/issues/36"
        >the original Github issue</a
      >, quoting this document where necessary.
    </p>

    <h2>TODO:</h2>

    <h3>ADR</h3>

    <p>Are we doing this? Why/why not?</p>

    <h3>MVP</h3>

    <p>What is it? Where does all this live? How will it be documented?</p>

    <h3>Page Load</h3>

    <p>
      How can we only apply the one state we need on page load? Currently it
      looks through each state and applies it if the media-query is a match. In
      our example above, if your browser window is over 1100px wide on load,
      this happens:
    </p>

    <ol>
      <li>Render default state (as if no JavaScript)</li>
      <li><code>SauceComponent</code> kicks in.</li>
      <li>First state is applied, because min-width > 500px</li>
      <li>
        First state is removed, second state is applied, because min-width >
        700px
      </li>
      <li>
        Second state is removed, third state is applied, because min-width >
        900px
      </li>
      <li>
        Third state is removed, fourth state is applied, because min-width >
        1100px
      </li>
    </ol>

    <p>What <em>should</em> happen is this:</p>

    <ol>
      <li>Render default state (as if no JavaScript)</li>
      <li><code>SauceComponent</code> kicks in.</li>
      <li>Fourth state is applied, because min-width > 1100px</li>
    </ol>

    <h3>DOM Updates</h3>

    <p>
      We’ll need to ensure that components are correctly handled when added to
      the DOM.
    </p>

    <p>
      We should also figure out what happens when a
      <code>SauceStateMachine</code> is applied to a component and some other
      piece of JavaScript attempts to explicitly override the
      <code>data-sauce-state</code> value.
    </p>

    <h3>Reducing repetition in the markup</h3>

    <p>
      If we have multiple copies of the same component with the same state
      rules, we should figured out how to provide the state rules in place
      common to all of them, rather than repeating every the
      <code>state</code> elements for every single instance. This would work,
      but would be sub-optimal.
    </p>

    <p>
      There are several potential solutions to this issue, which will have a
      knock-on effect to the performance of the utility script, so I won’t posit
      any ideas just yet, but I’d consider this feature as absolutely required
      for a v1 release.
    </p>

    <h3>Pure JavaScript interface?</h3>

    <p>
      Should it also be possible to configure components purely in JavaScript?
      Should this be <strong>the</strong> way to configure state on components,
      removing it from the markup altogether? What are the pros and cons for
      each approach?
    </p>

    <h3>Multiple query types</h3>

    <p>
      Currently the “fallback” behavior only works if all of your media queries
      are checking for the same value. For example, the
      <code>min-width</code> checks in our example.
    </p>

    <p>
      Consider that a component may require some state changes for min-width,
      but also includes state options for example:
    </p>

    <code>
      <pre>
&lt;state media="(prefers-color-scheme: dark)" value="dark-mode" /&gt;
&lt;state media="(min-width: 500px)" value="red" /&gt;
&lt;state media="(min-width: 700px)" value="blue" /&gt;</pre
      >
    </code>

    <p>
      In this scenario, the <code>dark-mode</code> state will be removed once
      the next media-query is satisfied: <code>min-width: 500px</code>. We would
      need a way to avoid this.
    </p>

    <p>
      Similarly, if the browser width dips below 500px, the next state checked
      will be the <code>prefers-color-scheme</code> media query, which doesn’t
      bear any real relation to the state the preceeded it.
    </p>

    <p>
      The difficulty here is that our current ways of delivering responsive
      designs is stacking ever-wider media queries atop one another, when in
      fact actual responsive design can encompass many other aspects of the
      user’s browser context. Our new tools should aim to move away from solely
      <code>min-width</code> ways of thinking.
    </p>

    <h3>Accessibility</h3>

    <p>
      We must ensure that the <code>state</code> elements don’t intefere with
      assisstive technologies.
    </p>
  </body>
</html>
